# Повторное использование кода. Stateful и stateless React-компоненты.

Всем нам рано или поздно при решении новой задачи приходит мысль, а нельзя ли для неё переиспользовать код из реализованной ранее аналогичной задачи? Думаю, что в такой момент нами движет что-то среднее между ленью и здравым смыслом. Ну не писать же всё с нуля? Далее появляется подлая мыслишка: а может просто «скопипастить» и не заморачиваться?) 

![image](https://user-images.githubusercontent.com/43491660/161631319-94692e94-30ec-45da-9327-f9038871c937.png)

## Концепция повторного использования кода. Зачем нужно писать повторно используемый код?

Все мы в начале своего «программистского» пути начинали переиспользовать код с ctrl+C ctrl+V. Некоторые так продолжают делать и дальше, аргументируя свои действия: «Ведь код и так будет работать. Зачем тратить время на что-то ещё? Задача решена, давайте следующую!». Соглашусь, код будет работать, но в дальнейшем такой подход неизбежно приведёт к проблемам при изменении и поддержке кодовой базы. Если вам вдруг понадобится поменять логику в коде, который был многократно скопирован, а не грамотно переиспользован, то вам потребуется найти все скопированные фрагменты и внести изменения в каждый из них, а потом ещё и поправить тесты для каждого из этих фрагментов. Вы ведь пишите тесты?

![image](https://user-images.githubusercontent.com/43491660/161631285-2295e633-5b5c-430d-a36e-91fb464b6c2e.png) 

Поэтому на мой взгляд лучше всё-таки тратить немного больше времени в начале, создавая код, который можно легко повторно использовать, чем тратить уйму времени на поддержку дублированного кода в будущем.

Теперь поговорим подробнее о подходе с повторным использованием кода. Основная концепция этого подхода состоит в том, что при проектировании компоненты разбивают сложные приложения на независимые части, которые проще реализовать. Я бы посоветовала подходить к повторному использованию кода не как к специальному процессу, а как к стратегии развития. То есть мы должны изначально создавать компоненты с учетом их повторного использования в будущем. В первую очередь мы прорабатываем архитектуру, а потом уже пишем код. На первый взгляд извлечение компонентов может показаться лишней и монотонной работой. Но когда у нас становится всё больше повторно используемых компонентов, это быстро окупается, ведь можно взять уже готовый компонент для решения своей задачи. Особенно заметно это становится в больших приложениях с обширной кодовой базой.

Выделение компонентов способствует созданию хорошей архитектуры. Код, созданный из качественно спроектированных компонентов намного легче читать и воспринимать, а отсутствие дублирования кода позволит упростить багфикс, так как правки нужно будет вносить только в одном месте, а не искать по всему проекту нужные строчки кода. Чем короче код, тем он надежнее, в нем сложнее запутаться и проще увидеть ошибку. Не бойтесь разделять компоненты на более мелкие части. Не даром существует такой принцип DRY: «Don’t repeat yourself».

Как понять, что нужно выделить компонент? Первым делом стоит обратить внимание на часто используемые части пользовательского интерфейса, например, на кнопку или панельку. А если у нас получается сложный компонент – это уже хороший кандидат для того, чтобы выделить в нем несколько подкомпонентов для упрощения работы с ним.

Теперь давайте перейдем к React-компонентам.

## Что такое компоненты React?

Компоненты React – это самодостаточные элементы, которые можно использовать на странице любое количество раз. Во многом компоненты ведут себя как обычные JavaSript функции. Они принимают входные данные, так называемые props, и возвращают React-элементы, описывающие то, что мы хотим увидеть на экране.

Проще всего объявить React-компонент как стрелочную функцию:

```
//Пример 1
const Button = (props) => (
	<button onClick={props.onClick}>Click me!</button>
)
```
В данном случаем компонент принимает в качестве параметра props с обработчиком клика и возвращает React-элемент в виде кнопки. Компоненты такого типа называются функциональными.

Также компонент можно создать путем расширения класса React.Component. Такие компоненты называют классовыми, у них есть доступ к методам жизненного цикла и состоянию.

Перепишем наш функциональный компонент в виде классового: 

```
//Пример 2
class Button extends React.Component {

        constructor(props) {
	super(props);
        }

        render() {
	<button onClick={props.onClick}>Click me!</button>
       }
	
}
```
Важно отметить, что компонент не должен менять свои props — вне зависимости от того, функциональный он или классовый. Это позволяет гарантировать, что компонент будет возвращать один и тот же результат для одинаковых аргументов.

Также React-компоненты можно разделять по наличию состояния. Состояние представляет собой объект, который хранит динамические данные компонента. На основе изменения своего состояния компонент перерисовывается и может передавать свойства своего состояния в дочерние компоненты в качестве props. Таким образом, компоненты без состояния называют stateless компонентами, а с состоянием – stateful. 

Приведенные выше примеры представляют собой stateless компоненты. Попробуем добавить объект состояния в классовый компонент. 

```
//Пример 3
class Button extends React.Component {

        constructor(props) {
	super(props);
this.state = { clickNumber : 0}; 
        }

const onClick = () => {
     this.setState({ count: this.state.clickNumber + 1 });
props.onClick();

}

        render() {
	<button onClick={() => onClick()}>You clicked { this.state.clickNumber } times!</button>
       }
	
}
```
В данном примере мы добавили объект состояния в класс Button, который отслеживает изменение количества нажатий на кнопку и отображает актуальную информацию на странице.

Часто говорят, что stateless компоненты – это только функциональные компоненты, а stateful – классовые, но это не так. В действительности наличие состояния не зависит от того, является ли компонент классовым или функциональным. Рассматривая примеры 2 и 3, мы убедились, что классовые компоненты могут не иметь состояние. Состояние в функциональных компонентах мы рассмотрим чуть позже, а сейчас поговорим подробнее про использование stateless и stateful компонентов.

(Stateless компоненты обычно отражают статическую часть кода, stateful компонент зависит от своего состояния, может его изменять.)

Когда нужно использовать stateless компонент?

1.	Когда нам не нужно состояние или внутренние переменные. 
2.	Когда элемент на странице не должен быть интерактивным, откликаться на действия пользователя.
3.	Когда нужен повторно используемый код. 

Когда нужно использовать stateful компонент?
1.	Когда элемент является интерактивным на странице, откликается на действия пользователя или изменять что-то со временем. 
2.	Когда мы перерисовываем компонент в зависимости от его состояния.
3.	 Когда элемент зависит от каких-то данных, но мы не можем их передать в качестве props.


До изобретения хуков в React функциональные компоненты могли быть только stateless. Благодаря хуку useState() функциональный компонент теперь тоже может быть stateful. 

## UseState

Прежде, чем перейти к useState, рассмотрим само понятие хуков. Хук – это специальная функция, которая позволяет «подцепиться» к возможностям React. Приведём пример хука UseState, который позволяет функциональным компонентам получить доступ к состояниям React. 

```
function Button {
    const [count, setCount] = useState(0);

    return (
      <div>
	<p>Вы кликнули {count} раз(а)</p>
	<button onClick={() => setCount(count + 1)}>
	       Нажми на меня
	</button>
      </div>
    )   
}

```

Та же самая кнопка, которая при клике увеличивает значение того, сколько раз на нее кликнули. Вызов UseState возвращает нам два значения: текущее состояние и функцию, которая обновляет состояние. Это очень похоже на то, как мы используем состояние в классовых компонентах.

Теперь посмотрим, как тот же код выглядит с классовым компонентом и состоянием для классового компонента.

```
class Button extends React.Component<Button, ButtonState> {
   construcor(props) {
       super(props);
       this.state = {
             count: 0
       };
   }

 render() {
     return (
	<div>
	      <p>Вы кликнули {this.state.count} раз(а)</p>
	      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
	       Нажми на меня
	     </button>
	</div>
     );
 }
}

```

Можно увидеть, что использование классового компонента длиннее, практически в два раза.  Лучше использовать функциональные компоненты с применением хуков, потому что это выглядит проще, надежнее, удобней в плане разделения состояний или использования других хуков и никак не отразится на вашей производительности.

Почему лучше использовать хук React UseState? 
1.	Во-первых, проще для понимания, потому что это обычные функции. 
2.	Во-вторых, не нужно иметь дело с this. Порой не очень удобно связывать функции, когда нужно использовать обработчик событий. Часто возникают проблемы, не все разбираются в том, как работает окружение. 
3.	В-третьих, синтаксис короче, меньше шансов на появление багов. Также состояние более детализировано, в классовых компонентах у нас один большой объект состояний. Когда мы что-то изменяем, обновление переменной состояния всегда замещает ее значение, а не осуществляем слияние. С хуком React мы можем разделить состояние и обновлять отдельно каждое значение.


Но это все теория, на практике возникает много вопросов, попробуем разобрать некоторые из них:

#### 1. Допустим, что мы решили делать повторно используемый компонент. Как это повлияет на нашу разработку?

Добавить: Одинаковый код у всех

С одной стороны вы потратите чуть-чуть больше времени, чтобы написать код. Но когда другой разработчик видит код с хорошим названием компонентов, из чего состоит один большой родительский компонент – он намного быстрее поймёт код и ему не придётся разбираться в функциях и тегах. 
А когда вы будете разрабатывать аналогичный компонент, вам не нужно опять думать, как это реализовать, писать код с нуля. У нас уже есть компоненты, которые вы можете использовать. Это ускорит разработку.

Также у вас  ускорится багфикс, когда вам нужно поправлять только в одном месте. Допустим вы встретились с ситуацией, когда в продукте: два одинаковых компонента созданы по-разному в разных местах. В одном месте нашли ошибку и поправили, а во втором само не подтянется, если вы не использовали повторно. В случае повторного использования, похожий компонент в совсем другом месте кода будет исправлен автоматически. 

#### 2. В каком случае компонент не стоит делать повторно используемым? Какие есть недостатки повторного использования кода?

Повторно используемые компоненты выглядят как хорошая идея, потому что позволяют не дублировать код и где-то ускорить разработку. Но при этом они являются причиной нестабильности приложений, потому что при багфиксе разработчик исправляет код в соответствии с тем сценарием использования компонента, который актуален для его конкретной ситуации. Он не думает о том, что этот компонент еще используется в десятке других сценариев. Его правка может отразиться совершенно непредсказуемым образом на незнакомых ему частях приложения. Такие ошибки очень трудно найти, потому что их никто не проверяет. 
Или другая ситуация. В процессе доработки и развития приложения иногда возникает потребность добавить новую функциональность в этот компонент. Самое простое, что разработчик находит возможным сделать, становится изменение кода этого компонента, добавить новые props, новую логику. Вся эта логика в итоге в процессе развития приложения накапливается в этом компоненте. Он обрастает десятками разных props, десятками сложных условий. Все это начинает выглядеть крайне страшно и хрупко. Трудно отлаживать такие вещи, потому что там в одном месте может быть несколько десятков сценариев использования каких-то условий непонятных. Это все превращается в кошмар.

#### 3. Как избежать проблем с переиспользуемыми компонентами?

Не следует подходить к разработке повторно используемых компонентов легкомысленно. Как бы просто это не казалось.Все зависит от того, как изначально продумывается архитектура. Для того, чтобы не изменять тот компонент, который уже выделили как отдельную единицу, лучше использовать компоненты высшего порядка или функции оболочки, которые имеют в props children, и просто сверху что-то «навешивать», чтобы не ломать уже существующие отдельные компоненты. Тогда проблемы не будет.

Конечно, очень сложно изначально придумать такую архитектуру, чтобы эти компоненты создать так, чтобы они изначально везде подходили. Нужно выделять максимально общие признаки, чтобы не создавалась ситуация, когда для одного момента нам нужно что-то изменить, а для другого оставить так же.

Если же всё равно не получается использовать такие высокоуровневые вещи повторно, когда в них всегда там что-то меняется, можно попытаться делать повторное использование компонента как можно меньше. Компонент можно использовать повторно, если, например, у него нет состояния. Чем меньше компонент, тем меньше будет с ним проблем при повторном использовании.

Такие компоненты нужно делать максимально похожими на html теги, чтобы они принимали все пропсы html. Чтобы, если компонент основан на теге div, он и вел себя как тег div. Тогда велика вероятность, что у вас получится расширить использование этого компонента, добавив обработчики событий, не изменяя его.

Если у вас возникает потребность создать какой-то более сложный компонент, здесь хорошим правилом будет составлять этот сложный компонент из более маленьких компонентов, делать некоторую композицию. Это нужно для того, чтобы модифицировать его под другой сценарий, когда появится такая необходимость. Чтобы в такой ситуации мы могли просто создать другую композицию, переиспользовать его составляющие, но создать при этом что-то другое.

#### 4. Иногда у партнеров возникают проблемы с повторным использованием компонентов. Когда они брали за основу мелкие композиции, но все отвалилось, потому что они рассчитывали на другой код. 

Автор повторно используемого кода должен понимать, что его код будет повторно использоваться. Если автор не подразумевал такое использование своего кода, какие-то моменты он мог не предусмотреть. 

Если делается, например, выпадающее меню, мы должны подход сохранять, расширяя функциональность, а не менять ее. Если мы предоставляем партнерам библиотеку повторно используемых компонентов, которые они могут использовать в своих расширениях, эта библиотека должна быть явно выделена в кодовой базе, а мы должны понимать, что поддерживаем совместимость и следим за тем, чтобы не поломать решение партнеров при доработке функциональности. 

Очень важно писать тесты, чтобы проверить, не поломалась ли функциональность. Код, который мы используем повторно, требует более тщательного тестирования. Это поможет уменьшить его хрупкость. Когда мы меняем повторно используемые компоненты, мы должны убедиться, что в приложении ничего не поломается. Для этого нужно протестировать его скриншот тестами, юнит тестами, это даст нам уверенность, что мы ничего не ломаем. 

#### 5. Почему нельзя сделать состояние с помощью замыкания без использования хука?

Проблема в том, что при изменении состояния нам нужно перерендерить компонент. Просто так изменять состояние неинтересно. А в функциональных компонентах нет возможности «триггернуть» изменение состояния. Эта возможность зашита в хуках, которые реализуются внутри реакта. При изменении состояния они тоже используют замыкание для хранения значения, но именно при изменении состояния они «триггерят» реакт, чтобы он перерисовал компонент. 

#### 6. Какие компоненты сейчас лучше использовать: функциональные или классовые?

Лучше использовать функциональные компоненты. Классовые компоненты вообще собираются, возможно, задеприкейтить в будущем. Это, скорее всего, произойдет не скоро, потому что используется очень большая кодовая база. Но даже если их вообще не выключат и не уберут, все равно вектор развития реакта в библиотеке, скорее всего, будет направлен на хуки, на функциональные компоненты, а классы будут потихоньку умирать. Новый код сейчас лучше писать на функциональных. 

## Что бы хотелось добавить..

Главное, что я хотела донести этой статьей: продуманная архитектура в начале разработки дает огромные плюсы при расширении кодовой базы и багфиксе. Поэтому прежде, чем писать код, уделите побольше времени на то, чтобы продумать архитектуру и написать тесты, чтобы обезопасить себя от ошибок. При этом нужно помнить, что повторное использование кода - это хорошо, но не надо слишком этим увлекаться, чтобы не выстрелить себе же в ногу. Если вы не уверены, что этот компонент достаточно общий и подходящий для выделения в повторно используемые компоненты, то оставьте эту навязчивую идею сделать все идеально переиспользуемым!

![image](https://user-images.githubusercontent.com/43491660/161631196-6746d054-6eb7-4fab-98f0-77a2fd01a087.png)

